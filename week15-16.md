# Week 15-16: GraalVM Native Image & AOT

## Learning Objectives
By the end of these 2 weeks, you will:
- [ ] Understand GraalVM architecture and native image compilation process
- [ ] Master native image configuration and metadata generation
- [ ] Build native images for Spring Boot applications with <100ms startup time
- [ ] Optimize native images for memory footprint and performance
- [ ] Handle native image limitations and compatibility issues
- [ ] Deploy production-ready native images in containerized environments

## Time Allocation (30 hours total)
- **Reading/Study**: 12 hours (40%)
- **Hands-on Practice**: 10.5 hours (35%)
- **Projects**: 7.5 hours (25%)

## Week 15: GraalVM Native Image Fundamentals

### Learning Materials
**Official Documentation:**
- [GraalVM Native Image Documentation](https://www.graalvm.org/latest/reference-manual/native-image/) (3 hours)
- [Native Image Configuration](https://www.graalvm.org/latest/reference-manual/native-image/metadata/) (2 hours)
- [Native Image Build Configuration](https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildConfiguration/) (1.5 hours)

**Spring Native Integration:**
- [Spring Native Documentation](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/) (2 hours)
- [Spring Boot Native Images](https://spring.io/blog/2021/03/11/announcing-spring-native-beta) (1 hour)

**Performance & Optimization:**
- [Native Image Performance Guide](https://www.graalvm.org/latest/reference-manual/native-image/overview/Optimizations/) (1.5 hours)
- [Native Image Memory Management](https://medium.com/graalvm/understanding-how-graal-works-a-java-jit-compiler-written-in-java-dccc6f2dd4a2) (1 hour)

**Video Resources:**
- [GraalVM Native Image Deep Dive](https://www.youtube.com/watch?v=pR5NDkIZBOA) - Oracle Code One (1.5 hours)
- [Building Native Images with GraalVM](https://www.youtube.com/watch?v=6g9JGL6uWpA) - Devoxx (1.5 hours)

### Hands-on Activities
1. **Native Image Build Process** (3.5 hours)
   ```bash
   # Install GraalVM and native-image
   # Download GraalVM CE from https://github.com/graalvm/graalvm-ce-builds/releases
   export JAVA_HOME=/path/to/graalvm
   export PATH=$JAVA_HOME/bin:$PATH
   gu install native-image

   # Build simple native image
   echo 'public class Hello { public static void main(String[] args) { System.out.println("Hello, Native World!"); } }' > Hello.java
   javac Hello.java
   native-image Hello
   ./hello

   # Build with reflection configuration
   native-image --no-fallback \
                --report-unsupported-elements-at-runtime \
                -H:ReflectionConfigurationFiles=reflection-config.json \
                Hello

   # Advanced build options
   native-image --no-fallback \
                --static \
                --libc=musl \
                -H:+StaticExecutableWithDynamicLibC \
                -H:Name=hello-static \
                Hello
   ```

   ```json
   // reflection-config.json example
   [
     {
       "name": "com.example.MyClass",
       "methods": [
         {"name": "<init>", "parameterTypes": []},
         {"name": "getValue", "parameterTypes": []}
       ],
       "fields": [
         {"name": "value"}
       ]
     }
   ]
   ```

2. **Native Image Metadata Generation** (2 hours)
   ```bash
   # Generate metadata using tracing agent
   java -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/native-image \
        -jar myapp.jar

   # Test different execution paths
   java -agentlib:native-image-agent=config-merge-dir=src/main/resources/META-INF/native-image \
        -jar myapp.jar --run-tests

   # Conditional configuration
   java -agentlib:native-image-agent=config-output-dir=conditional-config,caller-filter-file=filter.json \
        -jar myapp.jar
   ```

### Projects
**Project 1: Native Image Build Automation Tool** (4 hours)
```java
// Goal: Automated native image build optimization and configuration tool
public class NativeImageBuildOptimizer {
    // Features:
    // - Automatic metadata generation and validation
    // - Build configuration optimization
    // - Performance and size analysis
    // - Cross-platform build support
    // - CI/CD integration templates

    public BuildPlan optimizeBuild(ApplicationAnalysis analysis) {
        // Analyze application:
        // - Reflection usage patterns
        // - Resource bundle requirements
        // - JNI dependencies
        // - Serialization requirements

        return generateOptimalBuildConfiguration();
    }

    public class BuildPlan {
        private Set<String> requiredFeatures;
        private Map<String, String> buildArgs;
        private List<String> metadataFiles;
        private EstimatedMetrics metrics;

        // Estimated startup time, memory usage, binary size
    }
}
```

**Deliverables:**
- Automated native image build configuration generator
- Performance estimation tool for native vs JVM execution
- Cross-platform build scripts and Docker integration
- CI/CD pipeline templates for native image builds
- Metadata validation and optimization recommendations

**Success Criteria:**
- [ ] Generates optimal build configurations for different application types
- [ ] Reduces native image build time by 20-30%
- [ ] Provides accurate performance and size predictions
- [ ] Handles complex Spring Boot applications successfully

## Week 16: Production Native Images & Optimization

### Learning Materials
**Advanced Configuration:**
- [Native Image Advanced Features](https://www.graalvm.org/latest/reference-manual/native-image/overview/HostedvsRuntimeOptions/) (2 hours)
- [Native Image Security](https://www.graalvm.org/latest/security-guide/native-image/) (1.5 hours)

**Spring Boot Native:**
- [Spring Boot 3.0 Native Images](https://spring.io/blog/2022/09/26/native-support-in-spring-boot-3-0-0-m5) (1.5 hours)
- [Spring Native AOT Processing](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aot) (2 hours)

**Production Deployment:**
- [Native Images in Production](https://www.baeldung.com/spring-native-intro) (1.5 hours)
- [Container Optimization for Native Images](https://quarkus.io/guides/building-native-image#producing-a-native-executable) (1 hour)

**Performance Analysis:**
- [Native Image Performance Profiling](https://www.graalvm.org/latest/reference-manual/native-image/overview/Profiling/) (1.5 hours)
- [Memory Usage Optimization](https://medium.com/graalvm/instant-netty-startup-using-graalvm-native-image-generation-ed6f14ff7692) (1 hour)

### Hands-on Activities
1. **Spring Boot Native Image Build** (3.5 hours)
   ```xml
   <!-- pom.xml configuration for Spring Boot native -->
   <plugin>
       <groupId>org.graalvm.buildtools</groupId>
       <artifactId>native-maven-plugin</artifactId>
       <version>0.9.27</version>
       <extensions>true</extensions>
       <executions>
           <execution>
               <id>build-native</id>
               <goals>
                   <goal>compile-no-fork</goal>
               </goals>
               <phase>package</phase>
           </execution>
       </executions>
       <configuration>
           <buildArgs>
               <buildArg>--no-fallback</buildArg>
               <buildArg>--report-unsupported-elements-at-runtime</buildArg>
               <buildArg>-H:+StaticExecutableWithDynamicLibC</buildArg>
               <buildArg>-H:ResourceConfigurationFiles=src/main/resources/META-INF/native-image/resource-config.json</buildArg>
           </buildArgs>
       </configuration>
   </plugin>
   ```

   ```java
   // Application configuration for native compilation
   @SpringBootApplication
   @ImportRuntimeHints(MyAppRuntimeHints.class)
   public class NativeSpringBootApp {
       public static void main(String[] args) {
           SpringApplication.run(NativeSpringBootApp.class, args);
       }
   }

   // Custom runtime hints for native compilation
   public class MyAppRuntimeHints implements RuntimeHintsRegistrar {
       @Override
       public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
           // Register reflection hints
           hints.reflection().registerType(
               TypeReference.of("com.example.MyEntity"),
               MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,
               MemberCategory.INVOKE_DECLARED_METHODS
           );

           // Register resource hints
           hints.resources().registerPattern("templates/*.html");
           hints.resources().registerPattern("static/**");

           // Register serialization hints
           hints.serialization().registerType(MyEntity.class);
       }
   }
   ```

2. **Native Image Performance Optimization** (2 hours)
   ```bash
   # Profile native image performance
   native-image --no-fallback \
                -H:+PrintAnalysisCallTree \
                -H:+PrintImageElementSizes \
                -H:+ReportExceptionStackTraces \
                MyApp

   # Build with Profile-Guided Optimization (PGO)
   # Step 1: Build instrumented image
   native-image --pgo-instrument MyApp

   # Step 2: Run workload to collect profiles
   ./myapp --run-benchmark > /dev/null

   # Step 3: Build optimized image with collected profiles
   native-image --pgo=default.iprof MyApp

   # Static linking for minimal container images
   native-image --static \
                --libc=musl \
                -H:+StaticExecutableWithDynamicLibC \
                -H:Name=myapp-static \
                MyApp
   ```

### Projects
**Project 2: Production-Ready Spring Boot Native Application** (3.5 hours)
```java
// Goal: Complete Spring Boot application optimized for native compilation
@SpringBootApplication
@EnableScheduling
@EnableJpaRepositories
public class ProductionNativeApp {
    // Features to implement:
    // - REST API with database integration
    // - Caching with Redis/Caffeine
    // - Security with JWT authentication
    // - Metrics and monitoring
    // - Configuration management
    // - Error handling and logging

    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        SpringApplication.run(ProductionNativeApp.class, args);
        long endTime = System.currentTimeMillis();
        System.out.println("Application started in " + (endTime - startTime) + "ms");
    }
}

// Performance monitoring for native applications
@Component
public class NativePerformanceMonitor {
    private final MeterRegistry meterRegistry;

    public NativePerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        // Monitor memory usage (different from JVM)
        Gauge.builder("native.memory.rss")
            .register(meterRegistry, this, this::getResidentSetSize);

        // Monitor startup metrics
        Gauge.builder("native.startup.time")
            .register(meterRegistry, this, this::getStartupTime);
    }

    private double getResidentSetSize(NativePerformanceMonitor monitor) {
        // Implement native memory monitoring
        return getNativeMemoryUsage();
    }
}
```

**Deliverables:**
- Complete Spring Boot application with <100ms startup time
- Comprehensive native image configuration and optimization
- Docker multi-stage build for minimal container images (<50MB)
- Performance comparison dashboard (Native vs JVM)
- Production deployment templates for Kubernetes

**Success Criteria:**
- [ ] Achieves <100ms startup time consistently
- [ ] Memory footprint <100MB for typical web application
- [ ] Container image size <50MB
- [ ] Maintains full application functionality in native mode
- [ ] Demonstrates 50%+ improvement in cold start scenarios

## Advanced Native Image Concepts

### Understanding AOT Compilation
```java
// Code that works differently in native vs JVM
public class AOTConsiderations {

    // Reflection requires explicit configuration
    public void reflectionExample() {
        try {
            // This needs to be registered in reflection-config.json
            Class<?> clazz = Class.forName("com.example.MyClass");
            Object instance = clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            // Handle reflection exceptions
        }
    }

    // Dynamic proxy generation
    @Component
    public class ProxyConfiguration {
        @Bean
        @SuppressWarnings("unchecked")
        public <T> T createProxy(Class<T> interfaceClass) {
            return (T) Proxy.newProxyInstance(
                interfaceClass.getClassLoader(),
                new Class<?>[] { interfaceClass },
                new MyInvocationHandler()
            );
        }
    }

    // Resource loading considerations
    public void resourceLoading() {
        // Resources must be included in resource-config.json
        try (InputStream is = getClass().getResourceAsStream("/config.properties")) {
            Properties props = new Properties();
            props.load(is);
        } catch (IOException e) {
            // Handle resource loading
        }
    }
}
```

### Native Image Build Optimization
```dockerfile
# Multi-stage Docker build for native images
FROM ghcr.io/graalvm/graalvm-ce:latest AS builder

# Install native-image
RUN gu install native-image

WORKDIR /app
COPY pom.xml .
COPY src ./src

# Build application
RUN ./mvnw clean package -Pnative -DskipTests

# Runtime stage with minimal base image
FROM gcr.io/distroless/cc-debian11:latest
COPY --from=builder /app/target/myapp /app/myapp

# Create non-root user
USER 1001:1001

EXPOSE 8080
ENTRYPOINT ["/app/myapp"]
```

### Performance Monitoring for Native Images
```java
// Custom metrics for native applications
@Component
public class NativeImageMetrics {

    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReady() {
        // Measure and report startup metrics
        long startupTime = ManagementFactory.getRuntimeMXBean().getUptime();
        Metrics.gauge("application.startup.time", startupTime);

        // Memory metrics specific to native images
        long totalMemory = Runtime.getRuntime().totalMemory();
        long maxMemory = Runtime.getRuntime().maxMemory();

        Metrics.gauge("native.memory.total", totalMemory);
        Metrics.gauge("native.memory.max", maxMemory);
    }

    // Monitor native-specific performance characteristics
    @Scheduled(fixedRate = 30000)
    public void recordNativeMetrics() {
        // Native images don't have traditional GC
        // Monitor different memory characteristics
        recordNativeMemoryUsage();
        recordExecutionPerformance();
    }
}
```

## Weekly Checkpoints

### Week 15 Checkpoint
- [ ] Understands GraalVM native image compilation process
- [ ] Can build native images with proper configuration
- [ ] Built automated build optimization tools
- [ ] Understands native image limitations and workarounds

### Week 16 Checkpoint
- [ ] Can build production-ready Spring Boot native applications
- [ ] Achieved <100ms startup time targets
- [ ] Created optimized container images for native deployments
- [ ] Understands native image performance characteristics and monitoring

## Native Image Best Practices

### Configuration Management
```json
// Complete native-image configuration example
{
  "bundles": [
    {
      "name": "com.example.myapp",
      "condition": {
        "typeReachable": "com.example.MyMainClass"
      }
    }
  ],
  "reflection": [
    {
      "name": "com.example.MyEntity",
      "allDeclaredConstructors": true,
      "allDeclaredMethods": true,
      "allDeclaredFields": true
    }
  ],
  "resources": {
    "includes": [
      {"pattern": "\\Qtemplates/\\E.*\\.html$"},
      {"pattern": "\\Qstatic/\\E.*"},
      {"pattern": "\\Qapplication.properties\\E"}
    ]
  },
  "serialization": [
    {"name": "com.example.MyEntity"}
  ],
  "proxies": [
    ["com.example.MyInterface"]
  ]
}
```

### Build Performance Optimization
```bash
# Optimized build flags for production
native-image \
  --no-fallback \
  --report-unsupported-elements-at-runtime \
  -H:+StaticExecutableWithDynamicLibC \
  -H:+ReportExceptionStackTraces \
  -H:IncludeResources=".*\\.properties$" \
  -H:IncludeResources=".*\\.json$" \
  -H:ConfigurationFileDirectories=src/main/resources/META-INF/native-image \
  --enable-preview \
  -march=native \
  MyApp
```

### Container Optimization
```dockerfile
# Minimal container for native images
FROM scratch
COPY target/myapp /myapp
EXPOSE 8080
USER 1001:1001
ENTRYPOINT ["/myapp"]

# Alternative with debugging capabilities
FROM gcr.io/distroless/cc-debian11:debug
COPY target/myapp /myapp
EXPOSE 8080
USER 1001:1001
ENTRYPOINT ["/myapp"]
```

## Production Deployment Considerations

### Kubernetes Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: native-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: native-app
  template:
    metadata:
      labels:
        app: native-app
    spec:
      containers:
      - name: app
        image: native-app:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "64Mi"      # Much lower than JVM
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 5  # Much faster than JVM
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 1   # Nearly instant
          periodSeconds: 5
```

### Monitoring and Observability
- Native images require different monitoring approaches
- Memory usage patterns differ significantly from JVM
- No traditional garbage collection metrics
- Focus on startup time, memory efficiency, and throughput
- Custom metrics for native-specific characteristics

## Next Week Preview
Week 17-18 will focus on capstone projects, allowing you to choose and implement a comprehensive project that demonstrates mastery of JVM concepts learned throughout the program.