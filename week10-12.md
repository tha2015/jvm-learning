# Week 10-12: Virtual Threads & Structured Concurrency

## Learning Objectives
By the end of these 3 weeks, you will:
- [ ] Understand Project Loom architecture and virtual thread implementation
- [ ] Master structured concurrency patterns and APIs
- [ ] Build high-throughput applications using virtual threads
- [ ] Migrate existing thread-pool applications to virtual threads
- [ ] Analyze and optimize virtual thread performance patterns
- [ ] Understand carrier thread behavior and pinning scenarios

## Time Allocation (45 hours total)
- **Reading/Study**: 18 hours (40%)
- **Hands-on Practice**: 16 hours (35%)
- **Projects**: 11 hours (25%)

## Week 10: Project Loom Fundamentals & Virtual Thread Architecture

### Learning Materials
**JEP Specifications:**
- [JEP 444: Virtual Threads](https://openjdk.org/jeps/444) - Complete specification (3 hours)
- [JEP 453: Structured Concurrency (Preview)](https://openjdk.org/jeps/453) - Full specification (2 hours)

**Official Documentation:**
- [Oracle Virtual Threads Guide](https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html) (2 hours)
- [Structured Concurrency Guide](https://docs.oracle.com/en/java/javase/21/core/structured-concurrency.html) (1.5 hours)

**Online Courses:**
- [Rock the JVM - Advanced Java](https://rockthejvm.com/p/advanced-java) - Virtual Threads module (3 hours)

**Articles & Deep Dives:**
- [Project Loom: Understand the new Java concurrency model](https://www.marcobehler.com/guides/java-project-loom) (1.5 hours)
- [Virtual Threads: A Deep Dive](https://inside.java/2021/05/10/networking-nio-with-virtual-threads/) (1 hour)
- [Understanding Carrier Threads](https://blog.rockthejvm.com/ultimate-guide-to-java-virtual-threads/) (1 hour)

**Conference Talks:**
- [Project Loom: Modern Scalable Concurrency for Java](https://www.youtube.com/watch?v=NV46KFV1m-4) - Ron Pressler at Devoxx (1.5 hours)
- [Loom and Structured Concurrency](https://www.youtube.com/watch?v=2J2tJm_iwk0) - Oracle Code One (1.5 hours)

### Hands-on Activities
1. **Virtual Thread Basics** (3 hours)
   ```java
   // Basic virtual thread creation and execution
   public class VirtualThreadBasics {
       public void basicExample() {
           // Platform thread (traditional)
           Thread platformThread = Thread.ofPlatform()
               .name("platform-thread")
               .start(() -> System.out.println("Platform thread"));

           // Virtual thread
           Thread virtualThread = Thread.ofVirtual()
               .name("virtual-thread")
               .start(() -> System.out.println("Virtual thread"));

           // Virtual thread with executor
           try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
               executor.submit(() -> {
                   System.out.println("Virtual thread via executor");
               });
           }
       }

       public void massiveVirtualThreads() {
           // Demonstrate scalability - create millions of virtual threads
           var startTime = System.currentTimeMillis();
           try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
               for (int i = 0; i < 1_000_000; i++) {
                   executor.submit(() -> {
                       try {
                           Thread.sleep(Duration.ofSeconds(1));
                       } catch (InterruptedException e) {
                           Thread.currentThread().interrupt();
                       }
                   });
               }
           }
           System.out.println("Created 1M virtual threads in: " +
               (System.currentTimeMillis() - startTime) + "ms");
       }
   }
   ```

2. **Carrier Thread Analysis** (2.5 hours)
   ```java
   // Monitor carrier thread behavior
   public class CarrierThreadAnalysis {
       public void analyzeCarrierThreads() {
           // Enable virtual thread debug logging
           System.setProperty("jdk.tracePinnedThreads", "full");

           // Create virtual threads and monitor carrier threads
           try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
               for (int i = 0; i < 100; i++) {
                   executor.submit(this::blockingOperation);
               }
           }
       }

       private void blockingOperation() {
           try {
               // I/O operation - should not pin carrier thread
               Thread.sleep(100);

               // vs synchronized block - may pin carrier thread
               synchronized (this) {
                   Thread.sleep(100);
               }
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
           }
       }
   }
   ```

### Projects
**Project 1: Virtual Thread Performance Comparator** (4 hours)
```java
// Goal: Comprehensive performance comparison between platform and virtual threads
public class VirtualThreadPerformanceComparator {
    // Test scenarios:
    // - I/O intensive workloads (file operations, network calls)
    // - CPU intensive workloads
    // - Mixed workloads
    // - Memory consumption analysis
    // - Throughput and latency measurements

    public ComparisonReport runComparison() {
        // Implement benchmarks using JMH
        // Measure: throughput, latency, memory usage, CPU utilization
        // Generate detailed reports and recommendations
    }
}
```

**Deliverables:**
- JMH-based benchmark suite comparing platform vs virtual threads
- Automated report generation with performance visualizations
- Memory usage analysis and carrier thread monitoring
- Recommendations for thread model selection based on workload

**Success Criteria:**
- [ ] Accurately measures performance differences across workload types
- [ ] Identifies optimal use cases for virtual threads
- [ ] Provides clear migration recommendations
- [ ] Handles edge cases and resource constraints

## Week 11: Structured Concurrency Patterns & APIs

### Learning Materials
**Advanced Documentation:**
- [Structured Concurrency API Documentation](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html) (2 hours)
- [Scoped Values Documentation](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html) (1 hour)

**Design Patterns:**
- [Structured Concurrency Patterns](https://inside.java/2022/05/31/structured-concurrency-deep-dive/) (2 hours)
- [Error Handling in Structured Concurrency](https://www.baeldung.com/java-structured-concurrency) (1.5 hours)

**Research Papers:**
- [Structured Concurrency](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/) - Nathaniel J. Smith (1.5 hours)

**Video Resources:**
- [Structured Concurrency in Practice](https://www.youtube.com/watch?v=2dKgtNJmnTg) - Spring I/O (1 hour)
- [Beyond Virtual Threads: Structured Concurrency](https://www.youtube.com/watch?v=8lFRMvB1zGc) (1 hour)

### Hands-on Activities
1. **Structured Concurrency Implementation** (3.5 hours)
   ```java
   // Implementing common structured concurrency patterns
   public class StructuredConcurrencyPatterns {

       // Fork-Join pattern with structured concurrency
       public UserProfile fetchUserProfile(String userId) {
           try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
               var userTask = scope.fork(() -> fetchUser(userId));
               var preferencesTask = scope.fork(() -> fetchPreferences(userId));
               var historyTask = scope.fork(() -> fetchHistory(userId));

               scope.join();           // Wait for all tasks
               scope.throwIfFailed();  // Propagate exceptions

               return new UserProfile(
                   userTask.resultNow(),
                   preferencesTask.resultNow(),
                   historyTask.resultNow()
               );
           } catch (ExecutionException | InterruptedException e) {
               throw new RuntimeException("Failed to fetch user profile", e);
           }
       }

       // Race pattern - first successful result wins
       public String fetchFromMultipleSources(List<String> urls) {
           try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {
               for (String url : urls) {
                   scope.fork(() -> httpGet(url));
               }

               scope.join();
               return scope.result();
           } catch (ExecutionException | InterruptedException e) {
               throw new RuntimeException("All sources failed", e);
           }
       }

       // Custom structured task scope
       public class TimeoutScope<T> extends StructuredTaskScope<T> {
           private final Duration timeout;

           public TimeoutScope(Duration timeout) {
               this.timeout = timeout;
           }

           @Override
           protected void handleComplete(Subtask<? extends T> subtask) {
               if (subtask.state() == Subtask.State.SUCCESS) {
                   shutdown();
               }
           }
       }
   }
   ```

2. **Scoped Values Integration** (2 hours)
   ```java
   // Using scoped values for context propagation
   public class ScopedValueExample {
       private static final ScopedValue<String> REQUEST_ID = ScopedValue.newInstance();
       private static final ScopedValue<User> CURRENT_USER = ScopedValue.newInstance();

       public void handleRequest(String requestId, User user) {
           ScopedValue.where(REQUEST_ID, requestId)
                     .where(CURRENT_USER, user)
                     .run(() -> {
                         processRequest();
                     });
       }

       private void processRequest() {
           try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
               var task1 = scope.fork(this::subtask1);
               var task2 = scope.fork(this::subtask2);

               scope.join();
               scope.throwIfFailed();
           } catch (Exception e) {
               log("Error in request: " + REQUEST_ID.get(), e);
           }
       }

       private String subtask1() {
           // Can access REQUEST_ID and CURRENT_USER without passing parameters
           log("Subtask1 processing for user: " + CURRENT_USER.get().getName());
           return "result1";
       }
   }
   ```

### Projects
**Project 2: High-Performance Web Server** (3.5 hours)
```java
// Goal: Build a web server using virtual threads and structured concurrency
public class VirtualThreadWebServer {
    // Features:
    // - Handle thousands of concurrent connections
    // - Structured request processing pipeline
    // - Efficient resource management
    // - Graceful shutdown handling
    // - Performance monitoring and metrics

    public void start(int port) {
        try (var serverSocket = new ServerSocket(port);
             var executor = Executors.newVirtualThreadPerTaskExecutor()) {

            while (!Thread.currentThread().isInterrupted()) {
                var clientSocket = serverSocket.accept();
                executor.submit(() -> handleRequest(clientSocket));
            }
        }
    }

    private void handleRequest(Socket clientSocket) {
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
            // Parallel request processing
            var authTask = scope.fork(() -> authenticate(request));
            var dataTask = scope.fork(() -> fetchData(request));
            var cacheTask = scope.fork(() -> checkCache(request));

            scope.join();
            scope.throwIfFailed();

            // Combine results and send response
            sendResponse(response);
        }
    }
}
```

**Deliverables:**
- Full-featured HTTP server using virtual threads
- Structured concurrency for request processing pipelines
- Load testing results showing scalability improvements
- Performance comparison with traditional thread-pool servers
- Docker container with monitoring dashboard

**Success Criteria:**
- [ ] Handles >10,000 concurrent connections efficiently
- [ ] Demonstrates proper error handling and resource cleanup
- [ ] Shows measurable performance improvements over traditional approaches
- [ ] Includes comprehensive monitoring and alerting

## Week 12: Migration Strategies & Production Optimization

### Learning Materials
**Migration Guides:**
- [Migrating to Virtual Threads](https://inside.java/2022/05/30/on-migrating-to-virtual-threads/) (2 hours)
- [Virtual Threads Best Practices](https://www.baeldung.com/java-virtual-thread-vs-thread) (1.5 hours)

**Performance Analysis:**
- [Virtual Thread Performance Characteristics](https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html) (2 hours)
- [Avoiding Common Virtual Thread Pitfalls](https://foojay.io/today/java-19-virtual-threads-dude-wheres-my-lock/) (1 hour)

**Production Considerations:**
- [Virtual Threads in Production](https://spring.io/blog/2022/10/11/embracing-virtual-threads) - Spring Framework perspective (1.5 hours)
- [Monitoring Virtual Threads](https://blogs.oracle.com/javamagazine/post/java-loom-virtual-threads-platform-threads) (1 hour)

### Hands-on Activities
1. **Application Migration Workshop** (4 hours)
   ```java
   // Before: Traditional thread pool approach
   public class TraditionalThreadPoolService {
       private final ExecutorService executor = Executors.newFixedThreadPool(200);

       public CompletableFuture<String> processAsync(String input) {
           return CompletableFuture.supplyAsync(() -> {
               try {
                   Thread.sleep(1000); // Simulate I/O
                   return "Processed: " + input;
               } catch (InterruptedException e) {
                   Thread.currentThread().interrupt();
                   throw new RuntimeException(e);
               }
           }, executor);
       }
   }

   // After: Virtual thread approach
   public class VirtualThreadService {
       public String process(String input) {
           try {
               Thread.sleep(1000); // Same I/O operation
               return "Processed: " + input;
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
               throw new RuntimeException(e);
           }
       }

       public List<String> processMany(List<String> inputs) {
           try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
               var tasks = inputs.stream()
                   .map(input -> scope.fork(() -> process(input)))
                   .toList();

               scope.join();
               scope.throwIfFailed();

               return tasks.stream()
                   .map(Subtask::resultNow)
                   .toList();
           } catch (Exception e) {
               throw new RuntimeException("Processing failed", e);
           }
       }
   }
   ```

2. **Virtual Thread Monitoring** (2.5 hours)
   ```java
   // Monitor virtual thread behavior and performance
   public class VirtualThreadMonitor {
       public void monitorVirtualThreads() {
           // JFR events for virtual threads
           try (var recording = JFR.startRecording()) {
               recording.enable("jdk.VirtualThreadStart");
               recording.enable("jdk.VirtualThreadEnd");
               recording.enable("jdk.VirtualThreadPinned");

               // Run your virtual thread workload
               executeVirtualThreadWorkload();

               recording.dump(Paths.get("virtual-threads.jfr"));
           }
       }

       public void analyzePinningEvents() {
           // Detect and analyze thread pinning
           System.setProperty("jdk.tracePinnedThreads", "full");

           // Monitor carrier thread usage
           ManagementFactory.getPlatformMXBeans(ThreadMXBean.class)
               .forEach(bean -> {
                   System.out.println("Active threads: " + bean.getThreadCount());
               });
       }
   }
   ```

### Projects
**Project 3: Migration Assessment Tool** (3.5 hours)
```java
// Goal: Automated tool to assess applications for virtual thread migration
public class VirtualThreadMigrationAssessment {
    // Features:
    // - Static code analysis for virtual thread compatibility
    // - Performance modeling and predictions
    // - Migration effort estimation
    // - Risk assessment and mitigation strategies
    // - Automated refactoring suggestions

    public MigrationReport assessApplication(Path codebasePath) {
        // Analyze codebase for:
        // - Thread pool usage patterns
        // - Synchronization mechanisms that may cause pinning
        // - I/O intensive operations that benefit from virtual threads
        // - CPU intensive operations that may not benefit

        return generateMigrationPlan();
    }
}
```

**Deliverables:**
- Static analysis tool for virtual thread migration assessment
- Automated refactoring suggestions and code transformations
- Performance prediction models for virtual thread adoption
- Migration roadmap with effort estimates and risk analysis
- Integration with popular IDEs and build tools

**Success Criteria:**
- [ ] Accurately identifies virtual thread migration opportunities
- [ ] Provides reliable performance improvement predictions
- [ ] Generates actionable migration recommendations
- [ ] Handles large codebases (>100k LOC) efficiently

## Advanced Virtual Thread Concepts

### Thread Pinning Analysis
```java
// Understanding and avoiding thread pinning
public class ThreadPinningAnalysis {

    // Pinning scenario: synchronized blocks
    public void avoidSynchronizedBlocks() {
        // Instead of:
        synchronized (this) {
            Thread.sleep(1000); // Pins carrier thread
        }

        // Use:
        ReentrantLock lock = new ReentrantLock();
        lock.lock();
        try {
            Thread.sleep(1000); // Doesn't pin
        } finally {
            lock.unlock();
        }
    }

    // Pinning scenario: native method calls
    public void handleNativeCalls() {
        // Native calls may pin carrier threads
        // Monitor with: -Djdk.tracePinnedThreads=full
        System.loadLibrary("mylib"); // May cause pinning
    }
}
```

### Virtual Thread Lifecycle Management
```java
// Advanced virtual thread lifecycle patterns
public class VirtualThreadLifecycle {

    // Graceful shutdown with virtual threads
    public void gracefulShutdown() {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            // Submit tasks
            List<Future<?>> futures = new ArrayList<>();
            for (int i = 0; i < 1000; i++) {
                futures.add(executor.submit(this::longRunningTask));
            }

            // Shutdown gracefully
            executor.shutdown();
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    // Virtual thread pooling patterns
    public void virtualThreadPooling() {
        // Virtual threads are cheap - no need for traditional pooling
        // Instead of maintaining thread pools, create on demand
        Executors.newVirtualThreadPerTaskExecutor(); // Creates unlimited virtual threads
    }
}
```

## Weekly Checkpoints

### Week 10 Checkpoint
- [ ] Understands virtual thread architecture and implementation
- [ ] Can create and manage virtual threads effectively
- [ ] Built comprehensive performance comparison tools
- [ ] Understands carrier thread behavior and pinning scenarios

### Week 11 Checkpoint
- [ ] Masters structured concurrency patterns and APIs
- [ ] Can implement complex concurrent workflows using structured concurrency
- [ ] Built high-performance applications using virtual threads
- [ ] Understands scoped values and context propagation

### Week 12 Checkpoint
- [ ] Can migrate existing applications to virtual threads
- [ ] Understands production considerations and monitoring
- [ ] Built automated migration assessment tools
- [ ] Can optimize virtual thread performance in production environments

## Production Deployment Considerations

### JVM Flags for Virtual Threads
```bash
# Enable virtual thread optimizations
-XX:+UseZGC                    # Low-latency GC for better virtual thread performance
-XX:+UnlockExperimentalVMOptions
-Djdk.tracePinnedThreads=short # Monitor pinning in production

# Monitor virtual thread behavior
-XX:+FlightRecorder
-XX:StartFlightRecording=filename=vthreads.jfr,settings=profile
```

### Monitoring and Observability
```java
// Custom metrics for virtual thread monitoring
public class VirtualThreadMetrics {
    private final Counter virtualThreadsCreated = Counter.build()
        .name("virtual_threads_created_total")
        .help("Total virtual threads created")
        .register();

    private final Gauge carrierThreadsActive = Gauge.build()
        .name("carrier_threads_active")
        .help("Active carrier threads")
        .register();

    public void recordVirtualThreadCreation() {
        virtualThreadsCreated.inc();
    }
}
```

### Performance Tuning Guidelines
1. **Avoid synchronized blocks** - Use `ReentrantLock` instead
2. **Monitor carrier thread pool** - Default size = CPU cores
3. **Use structured concurrency** - Better resource management
4. **Profile pinning events** - Identify and eliminate pinning sources

## Next Week Preview
Week 13-14 will focus on production JVM tuning and container optimization, building on the concurrency patterns learned in these weeks.