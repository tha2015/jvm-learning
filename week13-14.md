# Week 13-14: Production JVM & Container Tuning

## Learning Objectives
By the end of these 2 weeks, you will:
- [ ] Master container-aware JVM tuning and resource management
- [ ] Implement comprehensive JVM monitoring with JMC, Arthas, and observability stacks
- [ ] Build production-ready monitoring pipelines (JFR → Prometheus → Grafana)
- [ ] Apply advanced JVM flags and optimization techniques for containerized environments
- [ ] Troubleshoot complex production JVM issues using diagnostic tools

## Time Allocation (30 hours total)
- **Reading/Study**: 12 hours (40%)
- **Hands-on Practice**: 10.5 hours (35%)
- **Projects**: 7.5 hours (25%)

## Week 13: Container-Aware JVM Tuning

### Learning Materials
**Container JVM Documentation:**
- [OpenJDK Container Awareness](https://developers.redhat.com/blog/2017/03/14/java-inside-docker) (2 hours)
- [JVM Container Settings](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html) (1.5 hours)
- [Docker and JVM Memory](https://www.oracle.com/technical-resources/articles/java/javacontainers.html) (1.5 hours)

**Kubernetes & JVM:**
- [JVM Best Practices for Kubernetes](https://kubernetes.io/blog/2022/09/26/java-memory-management-kubernetes/) (2 hours)
- [Container Resource Management](https://www.baeldung.com/ops/docker-jvm-heap-size) (1 hour)

**Performance Guides:**
- [JVM Performance Tuning for Containers](https://blog.gceasy.io/2020/11/05/best-practices-java-memory-arguments-for-containers/) (1.5 hours)
- [Containerized Java Application Optimization](https://developers.redhat.com/articles/2022/04/19/java-17-whats-new-openjdks-container-awareness) (1 hour)

**Video Resources:**
- [Java in Containers](https://www.youtube.com/watch?v=w1rZOY5gbvk) - Oracle Code One (1.5 hours)
- [Container Memory and the JVM](https://www.youtube.com/watch?v=Vt4G-pHXfs4) - Red Hat Developer (1 hour)

### Hands-on Activities
1. **Container JVM Configuration** (3.5 hours)
   ```dockerfile
   # Dockerfile with optimized JVM settings
   FROM openjdk:21-jre-slim

   # Container-aware JVM flags
   ENV JAVA_OPTS="-XX:+UseContainerSupport \
                  -XX:InitialRAMPercentage=50.0 \
                  -XX:MaxRAMPercentage=80.0 \
                  -XX:MinRAMPercentage=50.0 \
                  -XX:+UseG1GC \
                  -XX:+UseStringDeduplication \
                  -XX:+OptimizeStringConcat \
                  -Xss256k \
                  -XX:MetaspaceSize=128M \
                  -XX:MaxMetaspaceSize=256M"

   # Enable JFR for production monitoring
   ENV JFR_OPTS="-XX:+FlightRecorder \
                 -XX:StartFlightRecording=filename=/app/logs/app.jfr,maxsize=100M,maxage=1h \
                 -XX:FlightRecorderOptions=settings=profile"

   COPY target/app.jar /app/app.jar
   WORKDIR /app

   # Create logs directory for JFR files
   RUN mkdir -p /app/logs

   ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS $JFR_OPTS -jar app.jar"]
   ```

   ```yaml
   # Kubernetes deployment with resource constraints
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: java-app
   spec:
     replicas: 3
     selector:
       matchLabels:
         app: java-app
     template:
       metadata:
         labels:
           app: java-app
       spec:
         containers:
         - name: java-app
           image: java-app:latest
           resources:
             requests:
               memory: "512Mi"
               cpu: "500m"
             limits:
               memory: "1Gi"
               cpu: "1000m"
           env:
           - name: JAVA_OPTS
             value: "-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"
           ports:
           - containerPort: 8080
   ```

2. **Resource Optimization Testing** (2 hours)
   ```bash
   # Test different memory allocation strategies
   docker run --memory=1g --memory-swap=1g myapp \
     java -XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -jar app.jar

   # Compare with fixed heap size
   docker run --memory=1g --memory-swap=1g myapp \
     java -Xmx750m -jar app.jar

   # Monitor container resource usage
   docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}"
   ```

### Projects
**Project 1: Container JVM Optimization Suite** (4 hours)
```java
// Goal: Automated container JVM tuning and optimization toolkit
public class ContainerJVMOptimizer {
    // Features:
    // - Analyze container resource constraints
    // - Generate optimal JVM flags for different workload types
    // - Performance testing in containerized environments
    // - Resource utilization monitoring and alerting
    // - Automatic scaling recommendations

    public OptimizationPlan generateOptimizationPlan(ContainerSpec spec, WorkloadProfile workload) {
        // Analyze:
        // - Available memory and CPU
        // - Application characteristics (I/O vs CPU intensive)
        // - Expected load patterns
        // - GC requirements and latency targets

        return createOptimalConfiguration();
    }
}
```

**Deliverables:**
- Containerized JVM optimization toolkit with Docker integration
- Automated JVM flag generation based on container resources
- Performance benchmarking suite for containerized Java applications
- Kubernetes resource recommendation engine
- Monitoring dashboard for container JVM metrics

**Success Criteria:**
- [ ] Generates optimal JVM configurations for different container sizes
- [ ] Reduces memory overhead by 15-20% while maintaining performance
- [ ] Provides accurate resource utilization predictions
- [ ] Integrates seamlessly with container orchestration platforms

## Week 14: Production Monitoring & Observability

### Learning Materials
**Java Mission Control (JMC):**
- [JMC User Guide](https://docs.oracle.com/javacomponents/jmc-5-5/jmc-user-guide/intro.htm) (2 hours)
- [Advanced JMC Analysis](https://www.oracle.com/technical-resources/articles/java/jrockit-jmc.html) (1.5 hours)

**Arthas Documentation:**
- [Arthas User Guide](https://arthas.aliyun.com/en/doc/) - Complete documentation (2.5 hours)
- [Arthas Advanced Features](https://github.com/alibaba/arthas/blob/master/README_EN.md) (1 hour)

**Observability Stack:**
- [Prometheus JVM Metrics](https://prometheus.io/docs/instrumenting/exporters/) (1.5 hours)
- [Grafana JVM Dashboards](https://grafana.com/grafana/dashboards/4701) (1 hour)
- [OpenTelemetry for Java](https://opentelemetry.io/docs/instrumentation/java/) (1.5 hours)

**Production Monitoring:**
- [JFR to Prometheus Pipeline](https://github.com/moditect/jfr-to-prometheus) (1 hour)
- [Application Performance Monitoring Best Practices](https://www.baeldung.com/java-application-monitoring-tools) (1 hour)

### Hands-on Activities
1. **Advanced JMC Analysis** (3 hours)
   ```java
   // Generate JFR recordings optimized for production analysis
   public class ProductionJFRRecording {
       public void startContinuousRecording() {
           try (var recording = JFR.startRecording()) {
               // Configure for production use - low overhead
               recording.enable("jdk.CPULoad").withPeriod(Duration.ofSeconds(10));
               recording.enable("jdk.MemoryUsage").withPeriod(Duration.ofSeconds(10));
               recording.enable("jdk.GCConfiguration");
               recording.enable("jdk.GCHeapSummary");

               // Custom application events
               recording.enable("com.mycompany.BusinessTransaction");
               recording.enable("com.mycompany.DatabaseQuery");

               // Set up continuous recording with rotation
               recording.setMaxSize(DataAmount.ofMegabytes(100));
               recording.setMaxAge(Duration.ofHours(2));
               recording.setToDisk(true);

               // Keep recording running...
               Thread.sleep(Duration.ofHours(24));
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
           }
       }
   }
   ```

2. **Arthas Production Debugging** (2.5 hours)
   ```bash
   # Download and run Arthas
   curl -O https://arthas.aliyun.com/arthas-boot.jar
   java -jar arthas-boot.jar

   # Monitor method execution in real-time
   watch com.mycompany.service.UserService getUserById '{params, returnObj, #cost}' -x 2

   # Profile hot methods without restarting application
   profiler start --event cpu --duration 60 --format html

   # Analyze memory usage
   memory
   heapdump /tmp/heapdump.hprof

   # Monitor JVM metrics
   dashboard
   jvm

   # Trace method calls with timing
   trace com.mycompany.service.UserService getUserById -n 5 --skipJDKMethod false

   # Decompile classes at runtime
   jad com.mycompany.service.UserService getUserById

   # Monitor garbage collection
   vmtool --action getInstances --className java.lang.String --limit 10
   ```

### Projects
**Project 2: Production Monitoring Pipeline** (3.5 hours)
```java
// Goal: Complete JFR → Prometheus → Grafana monitoring pipeline
public class ProductionMonitoringPipeline {
    // Components:
    // - JFR data collection and parsing
    // - Prometheus metrics export
    // - Grafana dashboard automation
    // - Alert rule generation
    // - Custom business metrics integration

    public void setupMonitoringPipeline() {
        // 1. Configure JFR continuous recording
        configureJFRRecording();

        // 2. Set up JFR to Prometheus bridge
        startPrometheusExporter();

        // 3. Deploy Grafana dashboards
        deployGrafanaDashboards();

        // 4. Configure alerting rules
        setupAlertingRules();
    }

    private void configureJFRRecording() {
        // Continuous JFR recording with custom events
        JFRRecordingManager.startContinuousRecording();
    }

    private void startPrometheusExporter() {
        // Export JFR metrics to Prometheus format
        JFRToPrometheusExporter.start();
    }
}
```

**Deliverables:**
- Complete monitoring pipeline with JFR, Prometheus, and Grafana
- Automated dashboard deployment and configuration
- Custom alerting rules for JVM and application metrics
- Integration with existing APM solutions
- Docker Compose setup for easy deployment

**Success Criteria:**
- [ ] Provides comprehensive JVM and application visibility
- [ ] Generates actionable alerts for performance issues
- [ ] Integrates with existing monitoring infrastructure
- [ ] Maintains <1% performance overhead in production

## Advanced Production Tuning Techniques

### JVM Flag Optimization for Containers
```bash
# Memory management in containers
-XX:+UseContainerSupport              # Enable container awareness
-XX:InitialRAMPercentage=25.0         # Initial heap as % of container memory
-XX:MaxRAMPercentage=75.0             # Maximum heap as % of container memory
-XX:MinRAMPercentage=50.0             # Minimum heap as % of container memory

# GC optimization for containers
-XX:+UseG1GC                          # G1GC for balanced performance
-XX:MaxGCPauseMillis=100              # Target pause time
-XX:G1HeapRegionSize=16m              # Optimize for container memory
-XX:+G1UseAdaptiveIHOP                # Adaptive heap occupancy threshold

# Performance optimization
-XX:+UseStringDeduplication           # Reduce memory usage
-XX:+OptimizeStringConcat             # Optimize string operations
-XX:+UseCompressedOops                # Compressed object pointers
-XX:+UseCompressedClassPointers       # Compressed class pointers

# Monitoring and debugging
-XX:+FlightRecorder                   # Enable JFR
-XX:+UnlockDiagnosticVMOptions        # Enable diagnostic options
-XX:NativeMemoryTracking=summary      # Track native memory
```

### Kubernetes Resource Optimization
```yaml
# Production-ready Kubernetes deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: java-microservice
spec:
  replicas: 3
  selector:
    matchLabels:
      app: java-microservice
  template:
    metadata:
      labels:
        app: java-microservice
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/actuator/prometheus"
    spec:
      containers:
      - name: app
        image: java-microservice:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        env:
        - name: JAVA_OPTS
          value: >-
            -XX:+UseContainerSupport
            -XX:MaxRAMPercentage=75.0
            -XX:+UseG1GC
            -XX:MaxGCPauseMillis=100
            -XX:+FlightRecorder
            -XX:StartFlightRecording=filename=/app/logs/app.jfr,maxsize=50M,maxage=30m
        volumeMounts:
        - name: jfr-logs
          mountPath: /app/logs
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: jfr-logs
        emptyDir: {}
```

### Production Troubleshooting Workflows

#### Memory Issues
```bash
# 1. Quick memory analysis
jcmd <pid> GC.run_finalization
jcmd <pid> VM.memory_usage
jcmd <pid> VM.native_memory summary

# 2. Heap dump analysis
jcmd <pid> GC.run
jcmd <pid> VM.memory_usage
jmap -dump:format=b,file=heap.hprof <pid>

# 3. Analyze with Eclipse MAT or JMC
```

#### Performance Issues
```bash
# 1. CPU profiling with async-profiler
java -jar async-profiler.jar -e cpu -d 60 -f profile.html <pid>

# 2. JFR recording for comprehensive analysis
jcmd <pid> JFR.start duration=60s filename=perf.jfr

# 3. Method-level analysis with Arthas
watch com.company.service.SlowService slowMethod '{params, returnObj, #cost}' -x 2
```

#### GC Issues
```bash
# 1. GC logging analysis
-Xlog:gc*:gc.log:time,tags

# 2. GC tuning validation
jstat -gc -t <pid> 5s

# 3. Memory allocation profiling
java -jar async-profiler.jar -e alloc -d 30 -f alloc.html <pid>
```

## Weekly Checkpoints

### Week 13 Checkpoint
- [ ] Can optimize JVM settings for containerized environments
- [ ] Understands container resource management and Kubernetes integration
- [ ] Built automated container JVM optimization tools
- [ ] Can troubleshoot container-specific JVM issues

### Week 14 Checkpoint
- [ ] Masters production monitoring with JMC, Arthas, and observability stacks
- [ ] Built complete JFR → Prometheus → Grafana monitoring pipeline
- [ ] Can perform real-time production debugging without service interruption
- [ ] Understands advanced performance troubleshooting workflows

## Production Monitoring Checklist

### Essential Metrics to Monitor
- [ ] **Heap Memory**: Usage, GC frequency, GC pause times
- [ ] **CPU Utilization**: Overall and per-core usage
- [ ] **Thread Activity**: Thread count, blocked threads, deadlocks
- [ ] **Application Metrics**: Response times, throughput, error rates
- [ ] **Container Resources**: Memory limits, CPU throttling
- [ ] **Custom Business Metrics**: Transaction rates, user activity

### Alerting Rules
```yaml
# Prometheus alerting rules for JVM monitoring
groups:
- name: jvm-alerts
  rules:
  - alert: HighMemoryUsage
    expr: jvm_memory_used_bytes / jvm_memory_max_bytes > 0.8
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "High JVM memory usage detected"

  - alert: LongGCPauses
    expr: rate(jvm_gc_pause_seconds_sum[5m]) / rate(jvm_gc_pause_seconds_count[5m]) > 0.1
    for: 2m
    labels:
      severity: critical
    annotations:
      summary: "GC pause times are too high"

  - alert: HighCPUUsage
    expr: process_cpu_usage > 0.8
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High CPU usage detected"
```

## Next Week Preview
Week 15-16 will focus on GraalVM Native Image and AOT compilation, building on the production optimization knowledge from these weeks.